<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>P4Runtime_REST API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>P4Runtime_REST</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys
import atexit
from itertools import chain

sys.path.append(&#34;..&#34;)

import os
import re
import signal
from warnings import warn

from flask import Flask, flash, json, redirect, request
from p4.config.v1 import p4info_pb2
from werkzeug.utils import secure_filename

from network.build_environment import Runner
from network.p4_host import P4Host
from network.p4runtime_switch import P4RuntimeSwitch
from p4runtime_lib import bmv2, helper, convert


app = Flask(__name__)

UPLOAD_FOLDER = &#34;./uploads/&#34;
COMPILATION_FOLDER = &#34;./compiles/&#34;

app.config[&#39;UPLOAD_FOLDER&#39;] = UPLOAD_FOLDER
app.config[&#39;COMPILATION_FOLDER&#39;] = COMPILATION_FOLDER
app.config[&#39;SWS_CONNECTIONS&#39;] = []

ALLOWED_EXTENSIONS = {&#39;p4&#39;}

# &lt;Utils #
def _allowed_file(filename):
    &#34;&#34;&#34; Utility function to check if file is of allowed extension
    
        Attributes:
            - filename      : string        // File name
    &#34;&#34;&#34;
    return &#39;.&#39; in filename and \
           filename.rsplit(&#39;.&#39;, 1)[1].lower() in ALLOWED_EXTENSIONS

def _get_switch_conns(device_id):
    for sw_conn in app.config[&#39;SWS_CONNECTIONS&#39;]:
        if not device_id or sw_conn.device_id == int(device_id):
            yield sw_conn    
# Utils&gt; #

@app.route(&#39;/&#39;)
def index():
    return &#39;Welcome to controller api&#39;

# PASSING
@app.route(&#39;/p4runtime/files/upload&#39;, methods=[&#39;POST&#39;])
def upload_file():
    try:
        if request.method == &#39;POST&#39;:
            # check if the post request has the file part
            if &#39;file&#39; not in request.files:
                flash(&#39;No file part&#39;)
                return redirect(request.url)
            
            if not os.path.isdir(app.config[&#39;UPLOAD_FOLDER&#39;]):
                os.system(f&#34;mkdir {app.config[&#39;UPLOAD_FOLDER&#39;]}&#34;)
            
            file = request.files[&#39;file&#39;]
            # If the user does not select a file, the browser submits an
            # empty file without a filename.
            if file.filename == &#39;&#39;:
                flash(&#39;No selected file&#39;)
                return redirect(request.url)
            if file and _allowed_file(file.filename):
                filename = secure_filename(file.filename)
                file.save(os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;], filename))
            else:
                &#39;File format not allowed&#39;, 400
    except Exception as e:
        warn(&#34;upload_file(): &#34; + str(e))
        return e, 500
    return &#39;&#39;, 200

# TBT
@app.route(&#39;/p4runtime/files&#39;, methods=[&#39;GET&#39;])
def get_files():
    try:
        return [app.config[&#39;UPLOAD_FOLDER&#39;]+file_name for file_name in os.listdir(app.config[&#39;UPLOAD_FOLDER&#39;])], 200
    except Exception as e:
        warn(&#34;get_files(): &#34; + str(e))
        return e, 400
    
# TBT    
@app.route(&#39;/p4runtime/files/delete&#39;, methods=[&#39;DELETE&#39;])
def delete_file():
    try:
        os.remove(request.form[&#39;file_path&#39;])
        return &#39;&#39;, 200
    except Exception as e:
        warn(&#34;delete_file(): &#34; + str(e))
        return e, 400
  
# PASSING
@app.route(&#39;/p4runtime/connect&#39;, methods=[&#39;POST&#39;])
def connect_to_switch():
    &#34;&#34;&#34; Connect to bmv2 switch.
    
        Endpoint:
            - /p4runtime/connect

        Attributes:
            - addr                : string    // bmv2 IP:PORT address
            - device_id           : string    // device id
            - proto_dump_fpath    : string    // File to dump logs
    &#34;&#34;&#34;
    try:
        name = request.form[&#39;name&#39;]
        addr = request.form[&#39;address&#39;]
        device_id = (int)(request.form[&#39;device_id&#39;])
        proto_dump = &#34;./dumps/&#34; + request.form[&#39;proto_dump&#39;]

        if all(map(lambda conn: conn.device_id != device_id, app.config[&#39;SWS_CONNECTIONS&#39;])):
            conn = bmv2.Bmv2SwitchConnection(name=name,
                                            address=addr,
                                            device_id=device_id,
                                            proto_dump_file=f&#34;{proto_dump}{device_id}.txt&#34;)
            app.config[&#39;SWS_CONNECTIONS&#39;].append(conn)
        
        for sw_conn in app.config[&#39;SWS_CONNECTIONS&#39;]:
            print(f&#34;Connected to {sw_conn.name} at {sw_conn.address}&#34;)
        
    except Exception as e:
        warn(&#34;connect_to_switch(): &#34; + str(e))
        return e, 500
    
    return &#39;&#39;, 200

# PASSING
@app.route(&#39;/p4runtime/program&#39;, methods=[&#39;POST&#39;])
def program_switch():
    &#34;&#34;&#34; Program bmv2 switch.

        Endpoint:
            - /p4runtime/program

        Attributes:
            - p4file        : string    // P4 file path with which to compile the switch
            - device_id     : string    // Bmv2Switch to program (will program all if not specified)
    
    &#34;&#34;&#34;
    try:
        if not os.path.isfile(os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;], f&#34;{request.form[&#39;p4file&#39;]}.p4&#34;)):
            return &#39;File does not exist&#39;, 400
        
        p4info, p4json = _compile_p4(request.form[&#39;p4file&#39;])

        for sw_conn in _get_switch_conns(request.args.get(&#39;device_id&#39;, None)):
            sw_conn.p4info = p4info
            p4info_helper = helper.P4InfoHelper(sw_conn.p4info)
            sw_conn.MasterArbitrationUpdate()
            sw_conn.SetForwardingPipelineConfig(p4info=p4info_helper.p4info,
                                                bmv2_json_file_path=p4json)    
            
            print(f&#34;{sw_conn.name} programmed&#34;) 
        
    except Exception as e:
        warn(f&#34;program_switch(): {e}&#34;)
        return e, 500

    return &#39;&#39;, 200

# PASSING
def _compile_p4(p4file):
    try:
        if not os.path.isdir(app.config[&#39;COMPILATION_FOLDER&#39;]):
                os.system(f&#34;mkdir {app.config[&#39;COMPILATION_FOLDER&#39;]}&#34;)
                
        org = os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;], f&#34;{p4file}.p4&#34;)
        dst = os.path.join(app.config[&#39;COMPILATION_FOLDER&#39;], f&#34;{p4file}.p4info.txt&#34;)
        
        command = f&#34;p4c --target bmv2 --arch v1model -o {app.config[&#39;COMPILATION_FOLDER&#39;]} --p4runtime-files {dst} --std p4-16 {org}&#34;
        os.system(command)
        
        p4info = os.path.join(app.config[&#39;COMPILATION_FOLDER&#39;], f&#34;{p4file}.p4info.txt&#34;)
        p4json = os.path.join(app.config[&#39;COMPILATION_FOLDER&#39;], f&#34;{p4file}.json&#34;)
    except Exception as e:
        raise Exception(f&#39;Compilation failed: {e}&#39;)
        
    return p4info, p4json

# PASSING
@app.route(&#39;/p4runtime/inserttable&#39;, methods=[&#39;POST&#39;])
def insert_table():
    &#34;&#34;&#34; Program bmv2 switch.

        Endpoint:
            - /p4runtime/inserttable

        Attributes:
            - device_id         : string    // Bmv2Switch where to inser the table entry (will insert on switches all if not specified)
            - table             : string    // Table name
            - match             : string    // Matching packet field
            - action_name       : string    // Name of the action
            - default_action    : string    // Default action of the table
            - action_params     : string    // Action parameters
            - priority          : string    // Action priority
    &#34;&#34;&#34;
    try:
        for sw_conn in _get_switch_conns(request.form.get(&#39;device_id&#39;, None)):
            p4info_helper = helper.P4InfoHelper(sw_conn.p4info)
            
            match_fields=request.form.get(&#39;match&#39;,None)
            if match_fields is not None:
                match_fields = json.loads(match_fields)
                for key, value in match_fields.items():
                    match = re.match(r&#34;\(&#39;(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})&#39;,(\d{1,2})\)&#34;,value)
                    if match:
                        match_fields[key]=(str(match.group(1)),int(match.group(2)))
                
            action_params= request.form.get(&#39;action_params&#39;, None)
            if action_params is not None:
                action_params = json.loads(action_params)
                
            table_entry = p4info_helper.buildTableEntry(
                table_name=request.form[&#39;table&#39;],
                match_fields=match_fields,
                default_action=(bool)(request.form.get(&#39;default_action&#39;, False)),
                action_name=request.form.get(&#39;action_name&#39;,None),
                action_params=action_params,
                priority=request.form.get(&#39;priority&#39;, None))

            sw_conn.WriteTableEntry(table_entry)
            
            print(f&#34;Table inserted at {sw_conn.name}&#34;)
            
        return &#39;&#39;, 200
    except Exception as e:
        warn(f&#34;Failed configuration: {e}&#34;)
        return &#39;&#39;, 500

# PASSING
@app.route(&#39;/p4runtime/gettable&#39;, methods=[&#39;GET&#39;])
def get_table_entries():
    &#34;&#34;&#34; Retrieve bmv2 switch table entries
    
        Endpoint:
            - /p4runtime/gettable
    
        Attributes:
            - device_id         : number    // Bmv2Switch to program (will return all if not specified)
            - table_id          : number    // Table from which to return entries
            - table_name        : string    // Table from which to return entries (used instead of table_id)
    &#34;&#34;&#34;
    table_entries = {}
    try:
        for sw_conn in _get_switch_conns(request.args.get(&#39;device_id&#39;, None)):
            p4info_helper = helper.P4InfoHelper(sw_conn.p4info)
            
            table_id = request.args.get(&#39;table_id&#39;, None)
            table_name = request.args.get(&#39;table_name&#39;, None)
            
            if table_id is None and table_name is not None:
                table_id = p4info_helper.get_tables_id(table_name)
                
            for table in getattr(p4info_helper.p4info, &#34;tables&#34;):
                pre = table.preamble
                if pre.id == table_id or table_id is None:
                    if not sw_conn.name in table_entries.keys():
                        table_entries[sw_conn.name] = []
                    
                    for response in sw_conn.ReadTableEntries(table_id=pre.id):
                        for entity in response.entities:
                            table_entry = entity.table_entry
                            table_entries[sw_conn.name].append({
                                &#34;table_name&#34;: pre.name,
                                &#34;table_id&#34;: table_entry.table_id,
                                &#34;matches&#34;: [x for x in _get_field_matches(table_entry.match)],
                                &#34;action&#34;: _get_action(table_entry.action),
                                &#34;priority&#34;: table_entry.priority,
                                &#34;meter_config&#34;: {
                                        &#34;cir&#34;: table_entry.meter_config.cir,
                                        &#34;cburst&#34;: table_entry.meter_config.cburst,
                                        &#34;pir&#34;: table_entry.meter_config.pir,
                                        &#34;pburst&#34;: table_entry.meter_config.pburst
                                    },
                                &#34;counter_data&#34; : {
                                        &#34;byte_count&#34;: table_entry.counter_data.byte_count,
                                        &#34;packet_count&#34;: table_entry.counter_data.packet_count
                                    },
                                &#34;is_default_action&#34;: table_entry.is_default_action,
                                &#34;idle_timeout_ns&#34;: table_entry.idle_timeout_ns,
                                &#34;time_since_last_hit&#34;: table_entry.time_since_last_hit.elapsed_ns
                            })
                            
        print(table_entries) 
        return json.dumps(table_entries), 200
    
    except Exception as e:
        warn(f&#34;Failed to get table entry: {e}&#34;)
        return &#39;&#39;, 500

def _get_field_matches(matches_entry):
    for fldm in matches_entry:
        mtch = {}
        mtch[&#34;field_id&#34;] = fldm.field_id
        if len(repr(fldm.lpm)):
            mtch[&#34;lpm&#34;] = {
                &#34;value&#34;: convert.decodeIPv4(fldm.lpm.value),
                &#34;prefix_len&#34;: fldm.lpm.prefix_len
            }
        elif len(repr(fldm.exact)):
            mtch[&#34;exact&#34;] = {
                &#34;value&#34;: convert.decodeIPv4(fldm.exact.value)
            }
        elif len(repr(fldm.ternary)):
            mtch[&#34;ternary&#34;] = {
                &#34;value&#34;:  convert.decodeIPv4(fldm.ternary.value),
                &#34;mask&#34;: convert.decodeIPv4(fldm.ternary.mask)
            }
        elif len(repr(fldm.range)):
            mtch[&#34;range&#34;] = {
                &#34;low&#34;:  convert.decodeIPv4(fldm.range.low),
                &#34;high&#34;:  convert.decodeIPv4(fldm.range.high)
            }
        elif len(repr(fldm.optional)):
            mtch[&#34;exact&#34;] = {
                &#34;value&#34;: fldm.optional.value
            }
            
        yield mtch

def _get_action(table_action):
    if len(repr(table_action.action)):
        return {
            &#34;action_id&#34;: table_action.action.action_id,
            &#34;params&#34;:[{
                    &#34;param_id&#34;: x.param_id,
                    &#34;value&#34;: convert.decodeNum(x.value)
                } for x in table_action.action.params]
        }
    elif table_action.action_profile_member_id:
        return {
            &#34;action_profile_member_id&#34;: table_action.action_profile_member_id
        }
    elif len(repr(table_action.action_profile_group_id)):
        return {
            &#34;action_profile_group_id&#34;: table_action.action_profile_group_id
        }
    elif len(repr(table_action.action_profile_action_set)):
        return {
            &#34;action_profile_action_set&#34;: {
                &#34;action_profile_actions&#34;: [{
                    &#34;action&#34;: {
                            &#34;action_id&#34;: x.action.action_id,
                            &#34;params&#34;: [{
                                    &#34;param_id&#34;: y.param_id,
                                    &#34;value&#34;: convert.decodeNum(y.value)
                                } for y in x.action.params]
                        },
                    &#34;weight&#34;: x.weight,
                    &#34;watch_port&#34;: x.watch_port
                } for x in table_action.action_profile_action_set.action_profile_actions]
            }
        }
    
# PASSING
@app.route(&#39;/p4runtime/getcounters&#39;, methods=[&#39;GET&#39;])
def get_counters():
    &#34;&#34;&#34; Retrieve bmv2 switch table entries
    
        Endpoint:
            - /p4runtime/getcounters
    
        Attributes:
            - device_id         : number    // Bmv2Switch to program (will return counter for all switches all if not specified)
            - counter_name      : string    // Counter name
            - index             : number    // Index associated with the counter
            
        Attention:
            - For simplicity sake, you should configure you&#39;re counter indexes to be the match key in each table entry, that why you can always reference your counter index by the respective table entry match key
    &#34;&#34;&#34;
    try:
        device_id = request.args.get(&#39;device_id&#39;, None)
        counter_name = request.args.get(&#39;counter_name&#39;, None)
        index = int(request.args[&#39;index&#39;]) if &#39;index&#39; in request.args.keys() else 0
            
        counter_entries = {}    
        for sw_conn in _get_switch_conns(device_id):
            p4info_helper = helper.P4InfoHelper(sw_conn.p4info)
            counter_entries[sw_conn.name] = {
                &#34;device_id&#34;: sw_conn.device_id,
                &#34;counters&#34;: []
            }
            for counter in p4info_helper.p4info.counters:
                if not counter_name or counter.preamble.name == counter_name:
                    entries = []
                    for response in sw_conn.ReadCounters(counter.preamble.id, index):
                        for entity in response.entities:
                            entries.append({
                                &#34;index&#34;: str(entity.counter_entry.index.index),
                                &#34;packet_count&#34;: str(entity.counter_entry.data.packet_count),
                                &#34;byte_count&#34;: str(entity.counter_entry.data.byte_count)
                            })
                    counter_entries[sw_conn.name][&#39;counters&#39;].append({
                        &#34;id&#34;: counter.preamble.id,
                        &#34;name&#34;: counter.preamble.name,
                        &#34;entries&#34; : entries
                    })
        
        print(counter_entries)                
        
        return json.dumps(counter_entries), 200
    except Exception as e:
        warn(f&#34;Failed to get counters: {e}&#34;)
        return &#39;&#39;, 500            
    
# ATTENTION - Shutting Mininet down before exiting
def exit_handler(*args):
    clean()   
    exit()
    
def clean():
    if app.config.get(&#39;SWS_CONNECTIONS&#39;) != []:
        for sw_conn in app.config.get(&#39;SWS_CONNECTIONS&#39;):
            sw_conn.shutdown()

    if app.debug:
        os.system(&#39;sudo rm -r compiles uploads&#39;)
        
atexit.register(exit_handler)
signal.signal(signal.SIGTERM, exit_handler)
signal.signal(signal.SIGINT, exit_handler)

clean()

if __name__ == &#39;__main__&#39;:
    app.debug = False
    app.run(host=&#39;0.0.0.0&#39;, port=6000)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="P4Runtime_REST.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean():
    if app.config.get(&#39;SWS_CONNECTIONS&#39;) != []:
        for sw_conn in app.config.get(&#39;SWS_CONNECTIONS&#39;):
            sw_conn.shutdown()

    if app.debug:
        os.system(&#39;sudo rm -r compiles uploads&#39;)</code></pre>
</details>
</dd>
<dt id="P4Runtime_REST.connect_to_switch"><code class="name flex">
<span>def <span class="ident">connect_to_switch</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect to bmv2 switch.</p>
<h2 id="endpoint">Endpoint</h2>
<ul>
<li>/p4runtime/connect</li>
</ul>
<h2 id="attributes">Attributes</h2>
<ul>
<li>addr
: string
// bmv2 IP:PORT address</li>
<li>device_id
: string
// device id</li>
<li>proto_dump_fpath
: string
// File to dump logs</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/p4runtime/connect&#39;, methods=[&#39;POST&#39;])
def connect_to_switch():
    &#34;&#34;&#34; Connect to bmv2 switch.
    
        Endpoint:
            - /p4runtime/connect

        Attributes:
            - addr                : string    // bmv2 IP:PORT address
            - device_id           : string    // device id
            - proto_dump_fpath    : string    // File to dump logs
    &#34;&#34;&#34;
    try:
        name = request.form[&#39;name&#39;]
        addr = request.form[&#39;address&#39;]
        device_id = (int)(request.form[&#39;device_id&#39;])
        proto_dump = &#34;./dumps/&#34; + request.form[&#39;proto_dump&#39;]

        if all(map(lambda conn: conn.device_id != device_id, app.config[&#39;SWS_CONNECTIONS&#39;])):
            conn = bmv2.Bmv2SwitchConnection(name=name,
                                            address=addr,
                                            device_id=device_id,
                                            proto_dump_file=f&#34;{proto_dump}{device_id}.txt&#34;)
            app.config[&#39;SWS_CONNECTIONS&#39;].append(conn)
        
        for sw_conn in app.config[&#39;SWS_CONNECTIONS&#39;]:
            print(f&#34;Connected to {sw_conn.name} at {sw_conn.address}&#34;)
        
    except Exception as e:
        warn(&#34;connect_to_switch(): &#34; + str(e))
        return e, 500
    
    return &#39;&#39;, 200</code></pre>
</details>
</dd>
<dt id="P4Runtime_REST.delete_file"><code class="name flex">
<span>def <span class="ident">delete_file</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/p4runtime/files/delete&#39;, methods=[&#39;DELETE&#39;])
def delete_file():
    try:
        os.remove(request.form[&#39;file_path&#39;])
        return &#39;&#39;, 200
    except Exception as e:
        warn(&#34;delete_file(): &#34; + str(e))
        return e, 400</code></pre>
</details>
</dd>
<dt id="P4Runtime_REST.exit_handler"><code class="name flex">
<span>def <span class="ident">exit_handler</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_handler(*args):
    clean()   
    exit()</code></pre>
</details>
</dd>
<dt id="P4Runtime_REST.get_counters"><code class="name flex">
<span>def <span class="ident">get_counters</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve bmv2 switch table entries</p>
<h2 id="endpoint">Endpoint</h2>
<ul>
<li>/p4runtime/getcounters</li>
</ul>
<h2 id="attributes">Attributes</h2>
<ul>
<li>device_id
: number
// Bmv2Switch to program (will return counter for all switches all if not specified)</li>
<li>counter_name
: string
// Counter name</li>
<li>index
: number
// Index associated with the counter</li>
</ul>
<h2 id="attention">Attention</h2>
<ul>
<li>For simplicity sake, you should configure you're counter indexes to be the match key in each table entry, that why you can always reference your counter index by the respective table entry match key</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/p4runtime/getcounters&#39;, methods=[&#39;GET&#39;])
def get_counters():
    &#34;&#34;&#34; Retrieve bmv2 switch table entries
    
        Endpoint:
            - /p4runtime/getcounters
    
        Attributes:
            - device_id         : number    // Bmv2Switch to program (will return counter for all switches all if not specified)
            - counter_name      : string    // Counter name
            - index             : number    // Index associated with the counter
            
        Attention:
            - For simplicity sake, you should configure you&#39;re counter indexes to be the match key in each table entry, that why you can always reference your counter index by the respective table entry match key
    &#34;&#34;&#34;
    try:
        device_id = request.args.get(&#39;device_id&#39;, None)
        counter_name = request.args.get(&#39;counter_name&#39;, None)
        index = int(request.args[&#39;index&#39;]) if &#39;index&#39; in request.args.keys() else 0
            
        counter_entries = {}    
        for sw_conn in _get_switch_conns(device_id):
            p4info_helper = helper.P4InfoHelper(sw_conn.p4info)
            counter_entries[sw_conn.name] = {
                &#34;device_id&#34;: sw_conn.device_id,
                &#34;counters&#34;: []
            }
            for counter in p4info_helper.p4info.counters:
                if not counter_name or counter.preamble.name == counter_name:
                    entries = []
                    for response in sw_conn.ReadCounters(counter.preamble.id, index):
                        for entity in response.entities:
                            entries.append({
                                &#34;index&#34;: str(entity.counter_entry.index.index),
                                &#34;packet_count&#34;: str(entity.counter_entry.data.packet_count),
                                &#34;byte_count&#34;: str(entity.counter_entry.data.byte_count)
                            })
                    counter_entries[sw_conn.name][&#39;counters&#39;].append({
                        &#34;id&#34;: counter.preamble.id,
                        &#34;name&#34;: counter.preamble.name,
                        &#34;entries&#34; : entries
                    })
        
        print(counter_entries)                
        
        return json.dumps(counter_entries), 200
    except Exception as e:
        warn(f&#34;Failed to get counters: {e}&#34;)
        return &#39;&#39;, 500            </code></pre>
</details>
</dd>
<dt id="P4Runtime_REST.get_files"><code class="name flex">
<span>def <span class="ident">get_files</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/p4runtime/files&#39;, methods=[&#39;GET&#39;])
def get_files():
    try:
        return [app.config[&#39;UPLOAD_FOLDER&#39;]+file_name for file_name in os.listdir(app.config[&#39;UPLOAD_FOLDER&#39;])], 200
    except Exception as e:
        warn(&#34;get_files(): &#34; + str(e))
        return e, 400</code></pre>
</details>
</dd>
<dt id="P4Runtime_REST.get_table_entries"><code class="name flex">
<span>def <span class="ident">get_table_entries</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve bmv2 switch table entries</p>
<h2 id="endpoint">Endpoint</h2>
<ul>
<li>/p4runtime/gettable</li>
</ul>
<h2 id="attributes">Attributes</h2>
<ul>
<li>device_id
: number
// Bmv2Switch to program (will return all if not specified)</li>
<li>table_id
: number
// Table from which to return entries</li>
<li>table_name
: string
// Table from which to return entries (used instead of table_id)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/p4runtime/gettable&#39;, methods=[&#39;GET&#39;])
def get_table_entries():
    &#34;&#34;&#34; Retrieve bmv2 switch table entries
    
        Endpoint:
            - /p4runtime/gettable
    
        Attributes:
            - device_id         : number    // Bmv2Switch to program (will return all if not specified)
            - table_id          : number    // Table from which to return entries
            - table_name        : string    // Table from which to return entries (used instead of table_id)
    &#34;&#34;&#34;
    table_entries = {}
    try:
        for sw_conn in _get_switch_conns(request.args.get(&#39;device_id&#39;, None)):
            p4info_helper = helper.P4InfoHelper(sw_conn.p4info)
            
            table_id = request.args.get(&#39;table_id&#39;, None)
            table_name = request.args.get(&#39;table_name&#39;, None)
            
            if table_id is None and table_name is not None:
                table_id = p4info_helper.get_tables_id(table_name)
                
            for table in getattr(p4info_helper.p4info, &#34;tables&#34;):
                pre = table.preamble
                if pre.id == table_id or table_id is None:
                    if not sw_conn.name in table_entries.keys():
                        table_entries[sw_conn.name] = []
                    
                    for response in sw_conn.ReadTableEntries(table_id=pre.id):
                        for entity in response.entities:
                            table_entry = entity.table_entry
                            table_entries[sw_conn.name].append({
                                &#34;table_name&#34;: pre.name,
                                &#34;table_id&#34;: table_entry.table_id,
                                &#34;matches&#34;: [x for x in _get_field_matches(table_entry.match)],
                                &#34;action&#34;: _get_action(table_entry.action),
                                &#34;priority&#34;: table_entry.priority,
                                &#34;meter_config&#34;: {
                                        &#34;cir&#34;: table_entry.meter_config.cir,
                                        &#34;cburst&#34;: table_entry.meter_config.cburst,
                                        &#34;pir&#34;: table_entry.meter_config.pir,
                                        &#34;pburst&#34;: table_entry.meter_config.pburst
                                    },
                                &#34;counter_data&#34; : {
                                        &#34;byte_count&#34;: table_entry.counter_data.byte_count,
                                        &#34;packet_count&#34;: table_entry.counter_data.packet_count
                                    },
                                &#34;is_default_action&#34;: table_entry.is_default_action,
                                &#34;idle_timeout_ns&#34;: table_entry.idle_timeout_ns,
                                &#34;time_since_last_hit&#34;: table_entry.time_since_last_hit.elapsed_ns
                            })
                            
        print(table_entries) 
        return json.dumps(table_entries), 200
    
    except Exception as e:
        warn(f&#34;Failed to get table entry: {e}&#34;)
        return &#39;&#39;, 500</code></pre>
</details>
</dd>
<dt id="P4Runtime_REST.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/&#39;)
def index():
    return &#39;Welcome to controller api&#39;</code></pre>
</details>
</dd>
<dt id="P4Runtime_REST.insert_table"><code class="name flex">
<span>def <span class="ident">insert_table</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Program bmv2 switch.</p>
<h2 id="endpoint">Endpoint</h2>
<ul>
<li>/p4runtime/inserttable</li>
</ul>
<h2 id="attributes">Attributes</h2>
<ul>
<li>device_id
: string
// Bmv2Switch where to inser the table entry (will insert on switches all if not specified)</li>
<li>table
: string
// Table name</li>
<li>match
: string
// Matching packet field</li>
<li>action_name
: string
// Name of the action</li>
<li>default_action
: string
// Default action of the table</li>
<li>action_params
: string
// Action parameters</li>
<li>priority
: string
// Action priority</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/p4runtime/inserttable&#39;, methods=[&#39;POST&#39;])
def insert_table():
    &#34;&#34;&#34; Program bmv2 switch.

        Endpoint:
            - /p4runtime/inserttable

        Attributes:
            - device_id         : string    // Bmv2Switch where to inser the table entry (will insert on switches all if not specified)
            - table             : string    // Table name
            - match             : string    // Matching packet field
            - action_name       : string    // Name of the action
            - default_action    : string    // Default action of the table
            - action_params     : string    // Action parameters
            - priority          : string    // Action priority
    &#34;&#34;&#34;
    try:
        for sw_conn in _get_switch_conns(request.form.get(&#39;device_id&#39;, None)):
            p4info_helper = helper.P4InfoHelper(sw_conn.p4info)
            
            match_fields=request.form.get(&#39;match&#39;,None)
            if match_fields is not None:
                match_fields = json.loads(match_fields)
                for key, value in match_fields.items():
                    match = re.match(r&#34;\(&#39;(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})&#39;,(\d{1,2})\)&#34;,value)
                    if match:
                        match_fields[key]=(str(match.group(1)),int(match.group(2)))
                
            action_params= request.form.get(&#39;action_params&#39;, None)
            if action_params is not None:
                action_params = json.loads(action_params)
                
            table_entry = p4info_helper.buildTableEntry(
                table_name=request.form[&#39;table&#39;],
                match_fields=match_fields,
                default_action=(bool)(request.form.get(&#39;default_action&#39;, False)),
                action_name=request.form.get(&#39;action_name&#39;,None),
                action_params=action_params,
                priority=request.form.get(&#39;priority&#39;, None))

            sw_conn.WriteTableEntry(table_entry)
            
            print(f&#34;Table inserted at {sw_conn.name}&#34;)
            
        return &#39;&#39;, 200
    except Exception as e:
        warn(f&#34;Failed configuration: {e}&#34;)
        return &#39;&#39;, 500</code></pre>
</details>
</dd>
<dt id="P4Runtime_REST.program_switch"><code class="name flex">
<span>def <span class="ident">program_switch</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Program bmv2 switch.</p>
<h2 id="endpoint">Endpoint</h2>
<ul>
<li>/p4runtime/program</li>
</ul>
<h2 id="attributes">Attributes</h2>
<ul>
<li>p4file
: string
// P4 file path with which to compile the switch</li>
<li>device_id
: string
// Bmv2Switch to program (will program all if not specified)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/p4runtime/program&#39;, methods=[&#39;POST&#39;])
def program_switch():
    &#34;&#34;&#34; Program bmv2 switch.

        Endpoint:
            - /p4runtime/program

        Attributes:
            - p4file        : string    // P4 file path with which to compile the switch
            - device_id     : string    // Bmv2Switch to program (will program all if not specified)
    
    &#34;&#34;&#34;
    try:
        if not os.path.isfile(os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;], f&#34;{request.form[&#39;p4file&#39;]}.p4&#34;)):
            return &#39;File does not exist&#39;, 400
        
        p4info, p4json = _compile_p4(request.form[&#39;p4file&#39;])

        for sw_conn in _get_switch_conns(request.args.get(&#39;device_id&#39;, None)):
            sw_conn.p4info = p4info
            p4info_helper = helper.P4InfoHelper(sw_conn.p4info)
            sw_conn.MasterArbitrationUpdate()
            sw_conn.SetForwardingPipelineConfig(p4info=p4info_helper.p4info,
                                                bmv2_json_file_path=p4json)    
            
            print(f&#34;{sw_conn.name} programmed&#34;) 
        
    except Exception as e:
        warn(f&#34;program_switch(): {e}&#34;)
        return e, 500

    return &#39;&#39;, 200</code></pre>
</details>
</dd>
<dt id="P4Runtime_REST.upload_file"><code class="name flex">
<span>def <span class="ident">upload_file</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/p4runtime/files/upload&#39;, methods=[&#39;POST&#39;])
def upload_file():
    try:
        if request.method == &#39;POST&#39;:
            # check if the post request has the file part
            if &#39;file&#39; not in request.files:
                flash(&#39;No file part&#39;)
                return redirect(request.url)
            
            if not os.path.isdir(app.config[&#39;UPLOAD_FOLDER&#39;]):
                os.system(f&#34;mkdir {app.config[&#39;UPLOAD_FOLDER&#39;]}&#34;)
            
            file = request.files[&#39;file&#39;]
            # If the user does not select a file, the browser submits an
            # empty file without a filename.
            if file.filename == &#39;&#39;:
                flash(&#39;No selected file&#39;)
                return redirect(request.url)
            if file and _allowed_file(file.filename):
                filename = secure_filename(file.filename)
                file.save(os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;], filename))
            else:
                &#39;File format not allowed&#39;, 400
    except Exception as e:
        warn(&#34;upload_file(): &#34; + str(e))
        return e, 500
    return &#39;&#39;, 200</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="P4Runtime_REST.clean" href="#P4Runtime_REST.clean">clean</a></code></li>
<li><code><a title="P4Runtime_REST.connect_to_switch" href="#P4Runtime_REST.connect_to_switch">connect_to_switch</a></code></li>
<li><code><a title="P4Runtime_REST.delete_file" href="#P4Runtime_REST.delete_file">delete_file</a></code></li>
<li><code><a title="P4Runtime_REST.exit_handler" href="#P4Runtime_REST.exit_handler">exit_handler</a></code></li>
<li><code><a title="P4Runtime_REST.get_counters" href="#P4Runtime_REST.get_counters">get_counters</a></code></li>
<li><code><a title="P4Runtime_REST.get_files" href="#P4Runtime_REST.get_files">get_files</a></code></li>
<li><code><a title="P4Runtime_REST.get_table_entries" href="#P4Runtime_REST.get_table_entries">get_table_entries</a></code></li>
<li><code><a title="P4Runtime_REST.index" href="#P4Runtime_REST.index">index</a></code></li>
<li><code><a title="P4Runtime_REST.insert_table" href="#P4Runtime_REST.insert_table">insert_table</a></code></li>
<li><code><a title="P4Runtime_REST.program_switch" href="#P4Runtime_REST.program_switch">program_switch</a></code></li>
<li><code><a title="P4Runtime_REST.upload_file" href="#P4Runtime_REST.upload_file">upload_file</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>